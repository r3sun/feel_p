#include <stdio.h>
#include <signal.h>
#include <stdarg.h>
#include <string.h>
#include <Windows.h>
#include <math.h>
#include <time.h>

#if defined(unix) || defined(__unix) || defined(__unix__)

#include <unistd.h>
#include <termios.h>

int disable_line_buffer(void){
	struct termios term, oldterm;
	if (tcgetattr(STDIN_FILENO, &term)) return -1;
	oldterm = term;
	term.c_lflag &= ~(ECHO | ICANON);
	if (tcsetattr(STDIN_FILENO, TCSANOW, &term)) return -1;
	return 0;
}
int enable_line_buffer(void){
	struct termios term, oldterm;
	if (tcgetattr(STDIN_FILENO, &term)) return -1;
	oldterm = term;
	term.c_lflag &= (ECHO | ICANON);
	if (tcsetattr(STDIN_FILENO, TCSANOW, &term)) return -1;
	return 0;
}
#elif defined(__FreeBSD__)

#elif defined(__linux__) || defined(linux) || defined(__linux)
#include <unistd.h>
#include <termios.h>

int disable_line_buffer(void){
	struct termios term, oldterm;
	if (tcgetattr(STDIN_FILENO, &term)) return -1;
	oldterm = term;
	term.c_lflag &= ~(ECHO | ICANON);
	if (tcsetattr(STDIN_FILENO, TCSANOW, &term)) return -1;
	return 0;
}
int enable_line_buffer(void){
	struct termios term, oldterm;
	if (tcgetattr(STDIN_FILENO, &term)) return -1;
	oldterm = term;
	term.c_lflag &= (ECHO | ICANON);
	if (tcsetattr(STDIN_FILENO, TCSANOW, &term)) return -1;
	return 0;
}
#elif defined(_WIN32) || defined(_WIN64) || defined(__CYGWIN__)
#include <windows.h>

BOOL WINAPI disable_line_buffer(void){
	HANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);
	DWORD mode;
	if (!GetConsoleMode(hInput, &mode)) return FALSE;
	mode &= ~ENABLE_LINE_INPUT;
	if (!SetConsoleMode(hInput, mode)) return FALSE;
	return TRUE;
}
BOOL WINAPI enable_line_buffer(void){
	HANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);
	DWORD mode;
	if (!GetConsoleMode(hInput, &mode)) return FALSE;
	mode |= ENABLE_LINE_INPUT;
	if (!SetConsoleMode(hInput, mode)) return FALSE;
	return TRUE;
}
#endif


#define		BUFFER_SIZE	128

char strs[1882][70] = {
"char	dayw[]",
"{",
"	\" S  M Tu  W Th  F  S\"",
"};",
"char	*smon[]",
"{",
"	\"Jan\", \"Feb\", \"Mar\", \"Apr\",",
"	\"May\", \"Jun\", \"Jul\", \"Aug\",",
"	\"Sep\", \"Oct\", \"Nov\", \"Dec\",",
"};",
"char	string[432];",
"main(argc, argv)",
"char *argv[];",
"{",
"	register y, i, j;",
"	int m;",
"",
"	if(argc < 2) {",
"		printf(\"usage: cal [month] year\\n\");",
"		exit();",
"	}",
"	if(argc == 2)",
"		goto xlong;",
"",
"/*",
" *	print out just month",
" */",
"",
"	m = number(argv[1]);",
"	if(m<1 || m>12)",
"		goto badarg;",
"	y = number(argv[2]);",
"	if(y<1 || y>9999)",
"		goto badarg;",
"	printf(\"      %s %l\\n\", smon[m-1], y);",
"	printf(\"%s\\n\", dayw);",
"	cal(m, y, string, 24);",
"	for(i=0; i<6*24; i=+24)",
"		pstr(string+i, 24);",
"	exit();",
"",
"/*",
" *	print out complete year",
" */",
"",
"xlong:",
"	y = number(argv[1]);",
"	if(y<1 || y>9999)",
"		goto badarg;",
"	printf(\"\\n\\n\\n\");",
"	printf(\"				%l\\n\", y);",
"	printf(\"\\n\");",
"	for(i=0; i<12; i=+3) {",
"		for(j=0; j<6*72; j++)",
"			string[j] = '\\0';",
"		printf(\"	 %s\", smon[i]);",
"		printf(\"			%s\", smon[i+1]);",
"		printf(\"		       %s\\n\", smon[i+2]);",
"		printf(\"%s   %s   %s\\n\", dayw, dayw, dayw);",
"		cal(i+1, y, string, 72);",
"		cal(i+2, y, string+23, 72);",
"		cal(i+3, y, string+46, 72);",
"		for(j=0; j<6*72; j=+72)",
"			pstr(string+j, 72);",
"	}",
"	printf(\"\\n\\n\\n\");",
"	exit();",
"",
"badarg:",
"	printf(\"Bad argument\\n\");",
"}",
"",
"number(str)",
"char *str;",
"{",
"	register n, c;",
"	register char *s;",
"",
"	n = 0;",
"	s = str;",
"	while(c = *s++) {",
"		if(c<'0' || c>'9')",
"			return(0);",
"		n = n*10 + c-'0';",
"	}",
"	return(n);",
"}",
"",
"pstr(str, n)",
"char *str;",
"{",
"	register i;",
"	register char *s;",
"",
"	s = str;",
"	i = n;",
"	while(i--)",
"		if(*s++ == '\\0')",
"			s[-1] = ' ';",
"	i = n+1;",
"	while(i--)",
"		if(*--s != ' ')",
"			break;",
"	s[1] = '\\0';",
"	printf(\"%s\\n\", str);",
"}",
"",
"char	mon[]",
"{",
"	0,",
"	31, 29, 31, 30,",
"	31, 30, 31, 31,",
"	30, 31, 30, 31,",
"};",
"",
"cal(m, y, p, w)",
"char *p;",
"{",
"	register d, i;",
"	register char *s;",
"",
"	s = p;",
"	d = jan1(y);",
"	mon[2] = 29;",
"	mon[9] = 30;",
"",
"	switch((jan1(y+1)+7-d)%7) {",
"",
"	/*",
"	 *	non-leap year",
"	 */",
"	case 1:",
"		mon[2] = 28;",
"		break;",
"",
"	/*",
"	 *	1752",
"	 */",
"	default:",
"		mon[9] = 19;",
"		break;",
"",
"	/*",
"	 *	leap year",
"	 */",
"	case 2:",
"		;",
"	}",
"	for(i=1; i<m; i++)",
"		d =+ mon[i];",
"	d =% 7;",
"	s =+ 3*d;",
"	for(i=1; i<=mon[m]; i++) {",
"		if(i==3 & mon[m]==19) {",
"			i =+ 11;",
"			mon[m] =+ 11;",
"		}",
"		if(i > 9)",
"			*s = i/10+'0';",
"		s++;",
"		*s++ = i%10+'0';",
"		s++;",
"		if(++d == 7) {",
"			d = 0;",
"			s = p+w;",
"			p = s;",
"		}",
"	}",
"}",
"",
"/*",
" *	return day of the week",
" *	of jan 1 of given year",
" */",
"",
"jan1(yr)",
"{",
"	register y, d;",
"",
"/*",
" *	normal gregorian calendar",
" *	one extra day per four years",
" */",
"",
"	y = yr;",
"	d = 4+y+(y+3)/4;",
"",
"/*",
" *	julian calendar",
" *	regular gregorian",
" *	less three days per 400",
" */",
"",
"	if(y > 1800) {",
"		d =- (y-1701)/100;",
"		d =+ (y-1601)/400;",
"	}",
"",
"/*",
" *	great calendar changeover instant",
" */",
"",
"	if(y > 1752)",
"		d =+ 3;",
"",
"	return(d%7);",
"}",
"#",
"/*",
" * grep -- print lines matching (or not matching) a pattern",
" *",
" */",
"",
"#define	CCHR	2",
"#define	CDOT	4",
"#define	CCL	6",
"#define	NCCL	8",
"#define	CDOL	10",
"#define	CEOF	11",
"",
"#define	STAR	01",
"",
"#define	LBSIZE	256",
"#define	ESIZE	256",
"",
"char	ibuf[512];",
"char	expbuf[ESIZE];",
"int	lnum[2];",
"char	linebuf[LBSIZE+1];",
"int	bflag;",
"int	nflag;",
"int	cflag;",
"int	vflag;",
"int	nfile;",
"int	circf;",
"int	blkno;",
"int	tln[2];",
"",
"main(argc, argv)",
"char **argv;",
"{",
"	extern fout;",
"",
"	fout = dup(1);",
"	flush();",
"	while (--argc > 0 && (++argv)[0][0]=='-')",
"		switch (argv[0][1]) {",
"",
"		case 'v':",
"			vflag++;",
"			continue;",
"",
"		case 'b':",
"			bflag++;",
"			continue;",
"",
"		case 'c':",
"			cflag++;",
"			continue;",
"",
"		case 'n':",
"			nflag++;",
"			continue;",
"",
"		default:",
"			printf2(\"Unknown flag\\n\");",
"			continue;",
"		}",
"	if (argc<=0)",
"		exit(2);",
"	compile(*argv);",
"	nfile = --argc;",
"	if (argc<=0)",
"		execute(0);",
"	else while (--argc >= 0) {",
"		argv++;",
"		execute(*argv);",
"	}",
"	flush();",
"	exit(0);",
"}",
"",
"compile(astr)",
"char *astr;",
"{",
"	register c;",
"	register char *ep, *sp;",
"	char *lastep;",
"	int cclcnt;",
"",
"	ep = expbuf;",
"	sp = astr;",
"	if (*sp == '^') {",
"		circf++;",
"		sp++;",
"	}",
"	for (;;) {",
"		if (ep >= &expbuf[ESIZE])",
"			goto cerror;",
"		if ((c = *sp++) != '*')",
"			lastep = ep;",
"		switch (c) {",
"",
"		case '\\0':",
"			*ep++ = CEOF;",
"			return;",
"",
"		case '.':",
"			*ep++ = CDOT;",
"			continue;",
"",
"		case '*':",
"			if (lastep==0)",
"				goto defchar;",
"			*lastep =| STAR;",
"			continue;",
"",
"		case '$':",
"			if (*sp != '\\0')",
"				goto defchar;",
"			*ep++ = CDOL;",
"			continue;",
"",
"		case '[':",
"			*ep++ = CCL;",
"			*ep++ = 0;",
"			cclcnt = 1;",
"			if ((c = *sp++) == '^') {",
"				c = *sp++;",
"				ep[-2] = NCCL;",
"			}",
"			do {",
"				*ep++ = c;",
"				cclcnt++;",
"				if (c=='\\0' || ep >= &expbuf[ESIZE])",
"					goto cerror;",
"			} while ((c = *sp++) != ']');",
"			lastep[1] = cclcnt;",
"			continue;",
"",
"		case '\\\\':",
"			if ((c = *sp++) == '\\0')",
"				goto cerror;",
"		defchar:",
"		default:",
"			*ep++ = CCHR;",
"			*ep++ = c;",
"		}",
"	}",
"    cerror:",
"	printf2(\"RE error\\n\");",
"}",
"",
"execute(file)",
"{",
"	register char *p1, *p2;",
"	register c;",
"	int f;",
"	char *ebp, *cbp;",
"",
"	if (file) {",
"		if ((f = open(file, 0)) < 0) {",
"			printf2(\"Can't open %s\\n\", file);",
"		}",
"	} else",
"		f = 0;",
"	ebp = ibuf;",
"	cbp = ibuf;",
"	lnum[0] = 0;",
"	lnum[1] = 0;",
"	tln[0] = 0;",
"	tln[1] = 0;",
"	blkno = -1;",
"	for (;;) {",
"		if ((++lnum[1])==0)",
"			lnum[1]++;",
"		if((lnum[1]&0377) == 0)",
"			flush();",
"		p1 = linebuf;",
"		p2 = cbp;",
"		for (;;) {",
"			if (p2 >= ebp) {",
"				if ((c = read(f, ibuf, 512)) <= 0) {",
"					close(f);",
"					if (cflag) {",
"						if (nfile > 1)",
"							printf(\"%s:\", file);",
"						p1 = locv(tln[0],tln[1]);",
"						printf(\"%s\\n\", p1);",
"					}",
"					return;",
"				}",
"				blkno++;",
"				p2 = ibuf;",
"				ebp = ibuf+c;",
"			}",
"			if ((c = *p2++) == '\\n')",
"				break;",
"			if(c)",
"			if (p1 < &linebuf[LBSIZE-1])",
"				*p1++ = c;",
"		}",
"		*p1++ = 0;",
"		cbp = p2;",
"		p1 = linebuf;",
"		p2 = expbuf;",
"		if (circf) {",
"			if (advance(p1, p2))",
"				goto found;",
"			goto nfound;",
"		}",
"		/* fast check for first character */",
"		if (*p2==CCHR) {",
"			c = p2[1];",
"			do {",
"				if (*p1!=c)",
"					continue;",
"				if (advance(p1, p2))",
"					goto found;",
"			} while (*p1++);",
"			goto nfound;",
"		}",
"		/* regular algorithm */",
"		do {",
"			if (advance(p1, p2))",
"				goto found;",
"		} while (*p1++);",
"	nfound:",
"		if (vflag)",
"			succeed(file);",
"		continue;",
"	found:",
"		if (vflag==0)",
"			succeed(file);",
"	}",
"}",
"",
"advance(alp, aep)",
"{",
"	register char *lp, *ep, *curlp;",
"	char *nextep;",
"",
"	lp = alp;",
"	ep = aep;",
"	for (;;) switch (*ep++) {",
"",
"	case CCHR:",
"		if (*ep++ == *lp++)",
"			continue;",
"		return(0);",
"",
"	case CDOT:",
"		if (*lp++)",
"			continue;",
"		return(0);",
"",
"	case CDOL:",
"		if (*lp==0)",
"			continue;",
"		return(0);",
"",
"	case CEOF:",
"		return(1);",
"",
"	case CCL:",
"		if (cclass(ep, *lp++, 1)) {",
"			ep =+ *ep;",
"			continue;",
"		}",
"		return(0);",
"",
"	case NCCL:",
"		if (cclass(ep, *lp++, 0)) {",
"			ep =+ *ep;",
"			continue;",
"		}",
"		return(0);",
"",
"	case CDOT|STAR:",
"		curlp = lp;",
"		while (*lp++);",
"		goto star;",
"",
"	case CCHR|STAR:",
"		curlp = lp;",
"		while (*lp++ == *ep);",
"		ep++;",
"		goto star;",
"",
"	case CCL|STAR:",
"	case NCCL|STAR:",
"		curlp = lp;",
"		while (cclass(ep, *lp++, ep[-1]==(CCL|STAR)));",
"		ep =+ *ep;",
"		goto star;",
"",
"	star:",
"		do {",
"			lp--;",
"			if (advance(lp, ep))",
"				return(1);",
"		} while (lp > curlp);",
"		return(0);",
"",
"	default:",
"		printf2(\"RE botch\\n\");",
"	}",
"}",
"",
"cclass(aset, ac, af)",
"{",
"	register char *set, c;",
"	register n;",
"",
"	set = aset;",
"	if ((c = ac) == 0)",
"		return(0);",
"	n = *set++;",
"	while (--n)",
"		if (*set++ == c)",
"			return(af);",
"	return(!af);",
"}",
"",
"printf2(s, a)",
"{",
"	extern fout;",
"	flush();",
"	fout = 2;",
"	printf(s, a);",
"	flush();",
"	exit(2);",
"}",
"",
"succeed(f)",
"{",
"	if (cflag) {",
"		if (++tln[1]==0)",
"			tln[0]++;",
"		return;",
"	}",
"	if (nfile > 1)",
"		printf(\"%s:\", f);",
"	if (bflag)",
"		printf(\"%l:\", blkno);",
"	if (nflag)",
"		printf(\"%s:\", locv(lnum[0], lnum[1]));",
"	printf(\"%s\\n\", linebuf);",
"}",
"#",
"",
"/*",
" * Editor",
" */",
"",
"#define	SIGHUP	1",
"#define	SIGINTR	2",
"#define	SIGQUIT	3",
"#define	FNSIZE	64",
"#define	LBSIZE	512",
"#define	ESIZE	128",
"#define	GBSIZE	256",
"#define	NBRA	5",
"#define	EOF	-1",
"",
"#define	CBRA	1",
"#define	CCHR	2",
"#define	CDOT	4",
"#define	CCL	6",
"#define	NCCL	8",
"#define	CDOL	10",
"#define	CEOF	11",
"#define	CKET	12",
"",
"#define	STAR	01",
"",
"#define	error	goto errlab",
"#define	READ	0",
"#define	WRITE	1",
"",
"int	peekc;",
"int	lastc;",
"char	savedfile[FNSIZE];",
"char	file[FNSIZE];",
"char	linebuf[LBSIZE];",
"char	rhsbuf[LBSIZE/2];",
"char	expbuf[ESIZE+4];",
"int	circfl;",
"int	*zero;",
"int	*dot;",
"int	*dol;",
"int	*endcore;",
"int	*fendcore;",
"int	*addr1;",
"int	*addr2;",
"char	genbuf[LBSIZE];",
"int	count[2];",
"char	*nextip;",
"char	*linebp;",
"int	ninbuf;",
"int	io;",
"int	pflag;",
"int	onhup;",
"int	onquit;",
"int	vflag	1;",
"int	listf;",
"int	col;",
"char	*globp;",
"int	tfile	-1;",
"int	tline;",
"char	*tfname;",
"char	*loc1;",
"char	*loc2;",
"char	*locs;",
"char	ibuff[512];",
"int	iblock	-1;",
"char	obuff[512];",
"int	oblock	-1;",
"int	ichanged;",
"int	nleft;",
"int	errfunc();",
"int	*errlab	errfunc;",
"char	TMPERR[] \"TMP\";",
"int	names[26];",
"char	*braslist[NBRA];",
"char	*braelist[NBRA];",
"",
"main(argc, argv)",
"char **argv;",
"{",
"	register char *p1, *p2;",
"	extern int onintr();",
"",
"	onquit = signal(SIGQUIT, 1);",
"	onhup = signal(SIGHUP, 1);",
"	argv++;",
"	if (argc > 1 && **argv=='-') {",
"		vflag = 0;",
"		/* allow debugging quits? */",
"		if ((*argv)[1]=='q') {",
"			signal(SIGQUIT, 0);",
"			vflag++;",
"		}",
"		argv++;",
"		argc--;",
"	}",
"	if (argc>1) {",
"		p1 = *argv;",
"		p2 = savedfile;",
"		while (*p2++ = *p1++);",
"		globp = \"r\";",
"	}",
"	fendcore = sbrk(0);",
"	init();",
"	if ((signal(SIGINTR, 1) & 01) == 0)",
"		signal(SIGINTR, onintr);",
"	setexit();",
"	commands();",
"	unlink(tfname);",
"}",
"",
"commands()",
"{",
"	int getfile(), gettty();",
"	register *a1, c;",
"	register char *p;",
"	int r;",
"",
"	for (;;) {",
"	if (pflag) {",
"		pflag = 0;",
"		addr1 = addr2 = dot;",
"		goto print;",
"	}",
"	addr1 = 0;",
"	addr2 = 0;",
"	do {",
"		addr1 = addr2;",
"		if ((a1 = address())==0) {",
"			c = getchar();",
"			break;",
"		}",
"		addr2 = a1;",
"		if ((c=getchar()) == ';') {",
"			c = ',';",
"			dot = a1;",
"		}",
"	} while (c==',');",
"	if (addr1==0)",
"		addr1 = addr2;",
"	switch(c) {",
"",
"	case 'a':",
"		setdot();",
"		newline();",
"		append(gettty, addr2);",
"		continue;",
"",
"	case 'c':",
"		delete();",
"		append(gettty, addr1-1);",
"		continue;",
"",
"	case 'd':",
"		delete();",
"		continue;",
"",
"	case 'e':",
"		setnoaddr();",
"		if ((peekc = getchar()) != ' ')",
"			error;",
"		savedfile[0] = 0;",
"		init();",
"		addr2 = zero;",
"		goto caseread;",
"",
"	case 'f':",
"		setnoaddr();",
"		if ((c = getchar()) != '\\n') {",
"			peekc = c;",
"			savedfile[0] = 0;",
"			filename();",
"		}",
"		puts(savedfile);",
"		continue;",
"",
"	case 'g':",
"		global(1);",
"		continue;",
"",
"	case 'i':",
"		setdot();",
"		nonzero();",
"		newline();",
"		append(gettty, addr2-1);",
"		continue;",
"",
"	case 'k':",
"		if ((c = getchar()) < 'a' || c > 'z')",
"			error;",
"		newline();",
"		setdot();",
"		nonzero();",
"		names[c-'a'] = *addr2 | 01;",
"		continue;",
"",
"	case 'm':",
"		move(0);",
"		continue;",
"",
"	case '\\n':",
"		if (addr2==0)",
"			addr2 = dot+1;",
"		addr1 = addr2;",
"		goto print;",
"",
"	case 'l':",
"		listf++;",
"	case 'p':",
"		newline();",
"	print:",
"		setdot();",
"		nonzero();",
"		a1 = addr1;",
"		do",
"			puts(getline(*a1++));",
"		while (a1 <= addr2);",
"		dot = addr2;",
"		listf = 0;",
"		continue;",
"",
"	case 'q':",
"		setnoaddr();",
"		newline();",
"		unlink(tfname);",
"		exit();",
"",
"	case 'r':",
"	caseread:",
"		filename();",
"		if ((io = open(file, 0)) < 0) {",
"			lastc = '\\n';",
"			error;",
"		}",
"		setall();",
"		ninbuf = 0;",
"		append(getfile, addr2);",
"		exfile();",
"		continue;",
"",
"	case 's':",
"		setdot();",
"		nonzero();",
"		substitute(globp);",
"		continue;",
"",
"	case 't':",
"		move(1);",
"		continue;",
"",
"	case 'v':",
"		global(0);",
"		continue;",
"",
"	case 'w':",
"		setall();",
"		nonzero();",
"		filename();",
"		if ((io = creat(file, 0666)) < 0)",
"			error;",
"		putfile();",
"		exfile();",
"		continue;",
"",
"	case '=':",
"		setall();",
"		newline();",
"		count[1] = (addr2-zero)&077777;",
"		putd();",
"		putchar('\\n');",
"		continue;",
"",
"	case '!':",
"		unix();",
"		continue;",
"",
"	case EOF:",
"		return;",
"",
"	}",
"	error;",
"	}",
"}",
"",
"address()",
"{",
"	register *a1, minus, c;",
"	int n, relerr;",
"",
"	minus = 0;",
"	a1 = 0;",
"	for (;;) {",
"		c = getchar();",
"		if ('0'<=c && c<='9') {",
"			n = 0;",
"			do {",
"				n =* 10;",
"				n =+ c - '0';",
"			} while ((c = getchar())>='0' && c<='9');",
"			peekc = c;",
"			if (a1==0)",
"				a1 = zero;",
"			if (minus<0)",
"				n = -n;",
"			a1 =+ n;",
"			minus = 0;",
"			continue;",
"		}",
"		relerr = 0;",
"		if (a1 || minus)",
"			relerr++;",
"		switch(c) {",
"		case ' ':",
"		case '\\t':",
"			continue;",
"	",
"		case '+':",
"			minus++;",
"			if (a1==0)",
"				a1 = dot;",
"			continue;",
"",
"		case '-':",
"		case '^':",
"			minus--;",
"			if (a1==0)",
"				a1 = dot;",
"			continue;",
"	",
"		case '?':",
"		case '/':",
"			compile(c);",
"			a1 = dot;",
"			for (;;) {",
"				if (c=='/') {",
"					a1++;",
"					if (a1 > dol)",
"						a1 = zero;",
"				} else {",
"					a1--;",
"					if (a1 < zero)",
"						a1 = dol;",
"				}",
"				if (execute(0, a1))",
"					break;",
"				if (a1==dot)",
"					error;",
"			}",
"			break;",
"	",
"		case '$':",
"			a1 = dol;",
"			break;",
"	",
"		case '.':",
"			a1 = dot;",
"			break;",
"",
"		case '\\'':",
"			if ((c = getchar()) < 'a' || c > 'z')",
"				error;",
"			for (a1=zero; a1<=dol; a1++)",
"				if (names[c-'a'] == (*a1|01))",
"					break;",
"			break;",
"	",
"		default:",
"			peekc = c;",
"			if (a1==0)",
"				return(0);",
"			a1 =+ minus;",
"			if (a1<zero || a1>dol)",
"				error;",
"			return(a1);",
"		}",
"		if (relerr)",
"			error;",
"	}",
"}",
"",
"setdot()",
"{",
"	if (addr2 == 0)",
"		addr1 = addr2 = dot;",
"	if (addr1 > addr2)",
"		error;",
"}",
"",
"setall()",
"{",
"	if (addr2==0) {",
"		addr1 = zero+1;",
"		addr2 = dol;",
"		if (dol==zero)",
"			addr1 = zero;",
"	}",
"	setdot();",
"}",
"",
"setnoaddr()",
"{",
"	if (addr2)",
"		error;",
"}",
"",
"nonzero()",
"{",
"	if (addr1<=zero || addr2>dol)",
"		error;",
"}",
"",
"newline()",
"{",
"	register c;",
"",
"	if ((c = getchar()) == '\\n')",
"		return;",
"	if (c=='p' || c=='l') {",
"		pflag++;",
"		if (c=='l')",
"			listf++;",
"		if (getchar() == '\\n')",
"			return;",
"	}",
"	error;",
"}",
"",
"filename()",
"{",
"	register char *p1, *p2;",
"	register c;",
"",
"	count[1] = 0;",
"	c = getchar();",
"	if (c=='\\n' || c==EOF) {",
"		p1 = savedfile;",
"		if (*p1==0)",
"			error;",
"		p2 = file;",
"		while (*p2++ = *p1++);",
"		return;",
"	}",
"	if (c!=' ')",
"		error;",
"	while ((c = getchar()) == ' ');",
"	if (c=='\\n')",
"		error;",
"	p1 = file;",
"	do {",
"		*p1++ = c;",
"	} while ((c = getchar()) != '\\n');",
"	*p1++ = 0;",
"	if (savedfile[0]==0) {",
"		p1 = savedfile;",
"		p2 = file;",
"		while (*p1++ = *p2++);",
"	}",
"}",
"",
"exfile()",
"{",
"	close(io);",
"	io = -1;",
"	if (vflag) {",
"		putd();",
"		putchar('\\n');",
"	}",
"}",
"",
"onintr()",
"{",
"	signal(SIGINTR, onintr);",
"	putchar('\\n');",
"	lastc = '\\n';",
"	error;",
"}",
"",
"errfunc()",
"{",
"	register c;",
"",
"	listf = 0;",
"	puts(\"?\");",
"	count[0] = 0;",
"	seek(0, 0, 2);",
"	pflag = 0;",
"	if (globp)",
"		lastc = '\\n';",
"	globp = 0;",
"	peekc = lastc;",
"	while ((c = getchar()) != '\\n' && c != EOF);",
"	if (io > 0) {",
"		close(io);",
"		io = -1;",
"	}",
"	reset();",
"}",
"",
"getchar()",
"{",
"	if (lastc=peekc) {",
"		peekc = 0;",
"		return(lastc);",
"	}",
"	if (globp) {",
"		if ((lastc = *globp++) != 0)",
"			return(lastc);",
"		globp = 0;",
"		return(EOF);",
"	}",
"	if (read(0, &lastc, 1) <= 0)",
"		return(lastc = EOF);",
"	lastc =& 0177;",
"	return(lastc);",
"}",
"",
"gettty()",
"{",
"	register c, gf;",
"	register char *p;",
"",
"	p = linebuf;",
"	gf = globp;",
"	while ((c = getchar()) != '\\n') {",
"		if (c==EOF) {",
"			if (gf)",
"				peekc = c;",
"			return(c);",
"		}",
"		if ((c =& 0177) == 0)",
"			continue;",
"		*p++ = c;",
"		if (p >= &linebuf[LBSIZE-2])",
"			error;",
"	}",
"	*p++ = 0;",
"	if (linebuf[0]=='.' && linebuf[1]==0)",
"		return(EOF);",
"	return(0);",
"}",
"",
"getfile()",
"{",
"	register c;",
"	register char *lp, *fp;",
"",
"	lp = linebuf;",
"	fp = nextip;",
"	do {",
"		if (--ninbuf < 0) {",
"			if ((ninbuf = read(io, genbuf, LBSIZE)-1) < 0)",
"				return(EOF);",
"			fp = genbuf;",
"		}",
"		if (lp >= &linebuf[LBSIZE])",
"			error;",
"		if ((*lp++ = c = *fp++ & 0177) == 0) {",
"			lp--;",
"			continue;",
"		}",
"		if (++count[1] == 0)",
"			++count[0];",
"	} while (c != '\\n');",
"	*--lp = 0;",
"	nextip = fp;",
"	return(0);",
"}",
"",
"putfile()",
"{",
"	int *a1;",
"	register char *fp, *lp;",
"	register nib;",
"",
"	nib = 512;",
"	fp = genbuf;",
"	a1 = addr1;",
"	do {",
"		lp = getline(*a1++);",
"		for (;;) {",
"			if (--nib < 0) {",
"				write(io, genbuf, fp-genbuf);",
"				nib = 511;",
"				fp = genbuf;",
"			}",
"			if (++count[1] == 0)",
"				++count[0];",
"			if ((*fp++ = *lp++) == 0) {",
"				fp[-1] = '\\n';",
"				break;",
"			}",
"		}",
"	} while (a1 <= addr2);",
"	write(io, genbuf, fp-genbuf);",
"}",
"",
"append(f, a)",
"int (*f)();",
"{",
"	register *a1, *a2, *rdot;",
"	int nline, tl;",
"	struct { int integer; };",
"",
"	nline = 0;",
"	dot = a;",
"	while ((*f)() == 0) {",
"		if (dol >= endcore) {",
"			if (sbrk(1024) == -1)",
"				error;",
"			endcore.integer =+ 1024;",
"		}",
"		tl = putline();",
"		nline++;",
"		a1 = ++dol;",
"		a2 = a1+1;",
"		rdot = ++dot;",
"		while (a1 > rdot)",
"			*--a2 = *--a1;",
"		*rdot = tl;",
"	}",
"	return(nline);",
"}",
"",
"unix()",
"{",
"	register savint, pid, rpid;",
"	int retcode;",
"",
"	setnoaddr();",
"	if ((pid = fork()) == 0) {",
"		signal(SIGHUP, onhup);",
"		signal(SIGQUIT, onquit);",
"		execl(\"/bin/sh\", \"sh\", \"-t\", 0);",
"		exit();",
"	}",
"	savint = signal(SIGINTR, 1);",
"	while ((rpid = wait(&retcode)) != pid && rpid != -1);",
"	signal(SIGINTR, savint);",
"	puts(\"!\");",
"}",
"",
"delete()",
"{",
"	register *a1, *a2, *a3;",
"",
"	setdot();",
"	newline();",
"	nonzero();",
"	a1 = addr1;",
"	a2 = addr2+1;",
"	a3 = dol;",
"	dol =- a2 - a1;",
"	do",
"		*a1++ = *a2++;",
"	while (a2 <= a3);",
"	a1 = addr1;",
"	if (a1 > dol)",
"		a1 = dol;",
"	dot = a1;",
"}",
"",
"getline(tl)",
"{",
"	register char *bp, *lp;",
"	register nl;",
"",
"	lp = linebuf;",
"	bp = getblock(tl, READ);",
"	nl = nleft;",
"	tl =& ~0377;",
"	while (*lp++ = *bp++)",
"		if (--nl == 0) {",
"			bp = getblock(tl=+0400, READ);",
"			nl = nleft;",
"		}",
"	return(linebuf);",
"}",
"",
"putline()",
"{",
"	register char *bp, *lp;",
"	register nl;",
"	int tl;",
"",
"	lp = linebuf;",
"	tl = tline;",
"	bp = getblock(tl, WRITE);",
"	nl = nleft;",
"	tl =& ~0377;",
"	while (*bp = *lp++) {",
"		if (*bp++ == '\\n') {",
"			*--bp = 0;",
"			linebp = lp;",
"			break;",
"		}",
"		if (--nl == 0) {",
"			bp = getblock(tl=+0400, WRITE);",
"			nl = nleft;",
"		}",
"	}",
"	nl = tline;",
"	tline =+ (((lp-linebuf)+03)>>1)&077776;",
"	return(nl);",
"}",
"",
"getblock(atl, iof)",
"{",
"	extern read(), write();",
"	register bno, off;",
"	",
"	bno = (atl>>8)&0377;",
"	off = (atl<<1)&0774;",
"	if (bno >= 255) {",
"		puts(TMPERR);",
"		error;",
"	}",
"	nleft = 512 - off;",
"	if (bno==iblock) {",
"		ichanged =| iof;",
"		return(ibuff+off);",
"	}",
"	if (bno==oblock)",
"		return(obuff+off);",
"	if (iof==READ) {",
"		if (ichanged)",
"			blkio(iblock, ibuff, write);",
"		ichanged = 0;",
"		iblock = bno;",
"		blkio(bno, ibuff, read);",
"		return(ibuff+off);",
"	}",
"	if (oblock>=0)",
"		blkio(oblock, obuff, write);",
"	oblock = bno;",
"	return(obuff+off);",
"}",
"",
"blkio(b, buf, iofcn)",
"int (*iofcn)();",
"{",
"	seek(tfile, b, 3);",
"	if ((*iofcn)(tfile, buf, 512) != 512) {",
"		puts(TMPERR);",
"		error;",
"	}",
"}",
"",
"init()",
"{",
"	register char *p;",
"	register pid;",
"",
"	close(tfile);",
"	tline = 0;",
"	iblock = -1;",
"	oblock = -1;",
"	tfname = \"/tmp/exxxxx\";",
"	ichanged = 0;",
"	pid = getpid();",
"	for (p = &tfname[11]; p > &tfname[6];) {",
"		*--p = (pid&07) + '0';",
"		pid =>> 3;",
"	}",
"	close(creat(tfname, 0600));",
"	tfile = open(tfname, 2);",
"	brk(fendcore);",
"	dot = zero = dol = fendcore;",
"	endcore = fendcore - 2;",
"}",
"",
"global(k)",
"{",
"	register char *gp;",
"	register c;",
"	register int *a1;",
"	char globuf[GBSIZE];",
"",
"	if (globp)",
"		error;",
"	setall();",
"	nonzero();",
"	if ((c=getchar())=='\\n')",
"		error;",
"	compile(c);",
"	gp = globuf;",
"	while ((c = getchar()) != '\\n') {",
"		if (c==EOF)",
"			error;",
"		if (c=='\\\\') {",
"			c = getchar();",
"			if (c!='\\n')",
"				*gp++ = '\\\\';",
"		}",
"		*gp++ = c;",
"		if (gp >= &globuf[GBSIZE-2])",
"			error;",
"	}",
"	*gp++ = '\\n';",
"	*gp++ = 0;",
"	for (a1=zero; a1<=dol; a1++) {",
"		*a1 =& ~01;",
"		if (a1>=addr1 && a1<=addr2 && execute(0, a1)==k)",
"			*a1 =| 01;",
"	}",
"	for (a1=zero; a1<=dol; a1++) {",
"		if (*a1 & 01) {",
"			*a1 =& ~01;",
"			dot = a1;",
"			globp = globuf;",
"			commands();",
"			a1 = zero;",
"		}",
"	}",
"}",
"",
"substitute(inglob)",
"{",
"	register gsubf, *a1, nl;",
"	int getsub();",
"",
"	gsubf = compsub();",
"	for (a1 = addr1; a1 <= addr2; a1++) {",
"		if (execute(0, a1)==0)",
"			continue;",
"		inglob =| 01;",
"		dosub();",
"		if (gsubf) {",
"			while (*loc2) {",
"				if (execute(1)==0)",
"					break;",
"				dosub();",
"			}",
"		}",
"		*a1 = putline();",
"		nl = append(getsub, a1);",
"		a1 =+ nl;",
"		addr2 =+ nl;",
"	}",
"	if (inglob==0)",
"		error;",
"}",
"",
"compsub()",
"{",
"	register seof, c;",
"	register char *p;",
"	int gsubf;",
"",
"	if ((seof = getchar()) == '\\n')",
"		error;",
"	compile(seof);",
"	p = rhsbuf;",
"	for (;;) {",
"		c = getchar();",
"		if (c=='\\\\')",
"			c = getchar() | 0200;",
"		if (c=='\\n')",
"			error;",
"		if (c==seof)",
"			break;",
"		*p++ = c;",
"		if (p >= &rhsbuf[LBSIZE/2])",
"			error;",
"	}",
"	*p++ = 0;",
"	if ((peekc = getchar()) == 'g') {",
"		peekc = 0;",
"		newline();",
"		return(1);",
"	}",
"	newline();",
"	return(0);",
"}",
"",
"getsub()",
"{",
"	register char *p1, *p2;",
"",
"	p1 = linebuf;",
"	if ((p2 = linebp) == 0)",
"		return(EOF);",
"	while (*p1++ = *p2++);",
"	linebp = 0;",
"	return(0);",
"}",
"",
"dosub()",
"{",
"	register char *lp, *sp, *rp;",
"	int c;",
"",
"	lp = linebuf;",
"	sp = genbuf;",
"	rp = rhsbuf;",
"	while (lp < loc1)",
"		*sp++ = *lp++;",
"	while (c = *rp++) {",
"		if (c=='&') {",
"			sp = place(sp, loc1, loc2);",
"			continue;",
"		} else if (c<0 && (c =& 0177) >='1' && c < NBRA+'1') {",
"			sp = place(sp, braslist[c-'1'], braelist[c-'1']);",
"			continue;",
"		}",
"		*sp++ = c&0177;",
"		if (sp >= &genbuf[LBSIZE])",
"			error;",
"	}",
"	lp = loc2;",
"	loc2 = sp + linebuf - genbuf;",
"	while (*sp++ = *lp++)",
"		if (sp >= &genbuf[LBSIZE])",
"			error;",
"	lp = linebuf;",
"	sp = genbuf;",
"	while (*lp++ = *sp++);",
"}",
"",
"place(asp, al1, al2)",
"{",
"	register char *sp, *l1, *l2;",
"",
"	sp = asp;",
"	l1 = al1;",
"	l2 = al2;",
"	while (l1 < l2) {",
"		*sp++ = *l1++;",
"		if (sp >= &genbuf[LBSIZE])",
"			error;",
"	}",
"	return(sp);",
"}",
"",
"move(cflag)",
"{",
"	register int *adt, *ad1, *ad2;",
"	int getcopy();",
"",
"	setdot();",
"	nonzero();",
"	if ((adt = address())==0)",
"		error;",
"	newline();",
"	ad1 = addr1;",
"	ad2 = addr2;",
"	if (cflag) {",
"		ad1 = dol;",
"		append(getcopy, ad1++);",
"		ad2 = dol;",
"	}",
"	ad2++;",
"	if (adt<ad1) {",
"		dot = adt + (ad2-ad1);",
"		if ((++adt)==ad1)",
"			return;",
"		reverse(adt, ad1);",
"		reverse(ad1, ad2);",
"		reverse(adt, ad2);",
"	} else if (adt >= ad2) {",
"		dot = adt++;",
"		reverse(ad1, ad2);",
"		reverse(ad2, adt);",
"		reverse(ad1, adt);",
"	} else",
"		error;",
"}",
"",
"reverse(aa1, aa2)",
"{",
"	register int *a1, *a2, t;",
"",
"	a1 = aa1;",
"	a2 = aa2;",
"	for (;;) {",
"		t = *--a2;",
"		if (a2 <= a1)",
"			return;",
"		*a2 = *a1;",
"		*a1++ = t;",
"	}",
"}",
"",
"getcopy()",
"{",
"	if (addr1 > addr2)",
"		return(EOF);",
"	getline(*addr1++);",
"	return(0);",
"}",
"",
"compile(aeof)",
"{",
"	register eof, c;",
"	register char *ep;",
"	char *lastep;",
"	char bracket[NBRA], *bracketp;",
"	int nbra;",
"	int cclcnt;",
"",
"	ep = expbuf;",
"	eof = aeof;",
"	bracketp = bracket;",
"	nbra = 0;",
"	if ((c = getchar()) == eof) {",
"		if (*ep==0)",
"			error;",
"		return;",
"	}",
"	circfl = 0;",
"	if (c=='^') {",
"		c = getchar();",
"		circfl++;",
"	}",
"	if (c=='*')",
"		goto cerror;",
"	peekc = c;",
"	for (;;) {",
"		if (ep >= &expbuf[ESIZE])",
"			goto cerror;",
"		c = getchar();",
"		if (c==eof) {",
"			*ep++ = CEOF;",
"			return;",
"		}",
"		if (c!='*')",
"			lastep = ep;",
"		switch (c) {",
"",
"		case '\\\\':",
"			if ((c = getchar())=='(') {",
"				if (nbra >= NBRA)",
"					goto cerror;",
"				*bracketp++ = nbra;",
"				*ep++ = CBRA;",
"				*ep++ = nbra++;",
"				continue;",
"			}",
"			if (c == ')') {",
"				if (bracketp <= bracket)",
"					goto cerror;",
"				*ep++ = CKET;",
"				*ep++ = *--bracketp;",
"				continue;",
"			}",
"			*ep++ = CCHR;",
"			if (c=='\\n')",
"				goto cerror;",
"			*ep++ = c;",
"			continue;",
"",
"		case '.':",
"			*ep++ = CDOT;",
"			continue;",
"",
"		case '\\n':",
"			goto cerror;",
"",
"		case '*':",
"			if (*lastep==CBRA || *lastep==CKET)",
"				error;",
"			*lastep =| STAR;",
"			continue;",
"",
"		case '$':",
"			if ((peekc=getchar()) != eof)",
"				goto defchar;",
"			*ep++ = CDOL;",
"			continue;",
"",
"		case '[':",
"			*ep++ = CCL;",
"			*ep++ = 0;",
"			cclcnt = 1;",
"			if ((c=getchar()) == '^') {",
"				c = getchar();",
"				ep[-2] = NCCL;",
"			}",
"			do {",
"				if (c=='\\n')",
"					goto cerror;",
"				*ep++ = c;",
"				cclcnt++;",
"				if (ep >= &expbuf[ESIZE])",
"					goto cerror;",
"			} while ((c = getchar()) != ']');",
"			lastep[1] = cclcnt;",
"			continue;",
"",
"		defchar:",
"		default:",
"			*ep++ = CCHR;",
"			*ep++ = c;",
"		}",
"	}",
"   cerror:",
"	expbuf[0] = 0;",
"	error;",
"}",
"",
"execute(gf, addr)",
"int *addr;",
"{",
"	register char *p1, *p2, c;",
"",
"	if (gf) {",
"		if (circfl)",
"			return(0);",
"		p1 = linebuf;",
"		p2 = genbuf;",
"		while (*p1++ = *p2++);",
"		locs = p1 = loc2;",
"	} else {",
"		if (addr==zero)",
"			return(0);",
"		p1 = getline(*addr);",
"		locs = 0;",
"	}",
"	p2 = expbuf;",
"	if (circfl) {",
"		loc1 = p1;",
"		return(advance(p1, p2));",
"	}",
"	/* fast check for first character */",
"	if (*p2==CCHR) {",
"		c = p2[1];",
"		do {",
"			if (*p1!=c)",
"				continue;",
"			if (advance(p1, p2)) {",
"				loc1 = p1;",
"				return(1);",
"			}",
"		} while (*p1++);",
"		return(0);",
"	}",
"	/* regular algorithm */",
"	do {",
"		if (advance(p1, p2)) {",
"			loc1 = p1;",
"			return(1);",
"		}",
"	} while (*p1++);",
"	return(0);",
"}",
"",
"advance(alp, aep)",
"{",
"	register char *lp, *ep, *curlp;",
"	char *nextep;",
"",
"	lp = alp;",
"	ep = aep;",
"	for (;;) switch (*ep++) {",
"",
"	case CCHR:",
"		if (*ep++ == *lp++)",
"			continue;",
"		return(0);",
"",
"	case CDOT:",
"		if (*lp++)",
"			continue;",
"		return(0);",
"",
"	case CDOL:",
"		if (*lp==0)",
"			continue;",
"		return(0);",
"",
"	case CEOF:",
"		loc2 = lp;",
"		return(1);",
"",
"	case CCL:",
"		if (cclass(ep, *lp++, 1)) {",
"			ep =+ *ep;",
"			continue;",
"		}",
"		return(0);",
"",
"	case NCCL:",
"		if (cclass(ep, *lp++, 0)) {",
"			ep =+ *ep;",
"			continue;",
"		}",
"		return(0);",
"",
"	case CBRA:",
"		braslist[*ep++] = lp;",
"		continue;",
"",
"	case CKET:",
"		braelist[*ep++] = lp;",
"		continue;",
"",
"	case CDOT|STAR:",
"		curlp = lp;",
"		while (*lp++);",
"		goto star;",
"",
"	case CCHR|STAR:",
"		curlp = lp;",
"		while (*lp++ == *ep);",
"		ep++;",
"		goto star;",
"",
"	case CCL|STAR:",
"	case NCCL|STAR:",
"		curlp = lp;",
"		while (cclass(ep, *lp++, ep[-1]==(CCL|STAR)));",
"		ep =+ *ep;",
"		goto star;",
"",
"	star:",
"		do {",
"			lp--;",
"			if (lp==locs)",
"				break;",
"			if (advance(lp, ep))",
"				return(1);",
"		} while (lp > curlp);",
"		return(0);",
"",
"	default:",
"		error;",
"	}",
"}",
"",
"cclass(aset, ac, af)",
"{",
"	register char *set, c;",
"	register n;",
"",
"	set = aset;",
"	if ((c = ac) == 0)",
"		return(0);",
"	n = *set++;",
"	while (--n)",
"		if (*set++ == c)",
"			return(af);",
"	return(!af);",
"}",
"",
"putd()",
"{",
"	register r;",
"	extern ldivr;",
"",
"	count[1] = ldiv(count[0], count[1], 10);",
"	count[0] = 0;",
"	r = ldivr;",
"	if (count[1])",
"		putd();",
"	putchar(r + '0');",
"}",
"",
"puts(as)",
"{",
"	register char *sp;",
"",
"	sp = as;",
"	col = 0;",
"	while (*sp)",
"		putchar(*sp++);",
"	putchar('\\n');",
"}",
"",
"char	line[70];",
"char	*linp	line;",
"",
"putchar(ac)",
"{",
"	register char *lp;",
"	register c;",
"",
"	lp = linp;",
"	c = ac;",
"	if (listf) {",
"		col++;",
"		if (col >= 72) {",
"			col = 0;",
"			*lp++ = '\\\\';",
"			*lp++ = '\\n';",
"		}",
"		if (c=='\\t') {",
"			c = '>';",
"			goto esc;",
"		}",
"		if (c=='\\b') {",
"			c = '<';",
"		esc:",
"			*lp++ = '-';",
"			*lp++ = '\\b';",
"			*lp++ = c;",
"			goto out;",
"		}",
"		if (c<' ' && c!= '\\n') {",
"			*lp++ = '\\\\';",
"			*lp++ = (c>>3)+'0';",
"			*lp++ = (c&07)+'0';",
"			col =+ 2;",
"			goto out;",
"		}",
"	}",
"	*lp++ = c;",
"out:",
"	if(c == '\\n' || lp >= &line[64]) {",
"		linp = line;",
"		write(1, line, lp-line);",
"		return;",
"	}",
"	linp = lp;",
"}",
"",
"/*",
" * Get process ID routine if system call is unavailable.",
"getpid()",
"{",
"	register f;",
"	int b[1];",
"",
"	f = open(\"/dev/kmem\", 0);",
"	if(f < 0)",
"		return(-1);",
"	seek(f, 0140074, 0);",
"	read(f, b, 2);",
"	seek(f, b[0]+8, 0);",
"	read(f, b, 2);",
"	close(f);",
"	return(b[0]);",
"}",
" */"
};

void brk_hndl(int sig);
int rand_range(int start, int stop);
long long time_n_sec_ll();
int nsleep(long long t);
int tw_printf(int time, char *fmt, ...);


int main()
{
    int c;

	srand(time(NULL));
	signal(SIGINT, brk_hndl);
	disable_line_buffer();
	while ((c = getchar()) != EOF) {
        tw_printf(10, "%s\n", strs[rand_range(0, 397)]);
	}
    
	enable_line_buffer();
    return 0;
}
void brk_hndl(int sig)
{
		raise(SIGABRT);
}
int rand_range(int start, int stop)
{
	int rnum;
	rnum = rand();

	if (rnum > stop)
		rnum %= stop;
	if (rnum < start)
		rnum += (start - rnum) + (stop % start);

	return rnum;
}
long long time_n_sec_ll()
{
	long long ns;
	FILETIME s_t;
	ULARGE_INTEGER lrg;

	GetSystemTimeAsFileTime(&s_t);
	lrg.u.LowPart = s_t.dwLowDateTime;
	lrg.u.HighPart = s_t.dwHighDateTime;

	ns = (lrg.QuadPart * 100 - 11644473600000000000);

	return ns;
}
int msleep(long long t)
{
	long long d_nt;

	d_nt = time_n_sec_ll() + (t * 1e6);

	for(;;){
		if(time_n_sec_ll() >= d_nt) {
			return 1;
		}
	}
	return -1;
}
int tw_printf(int time, char *fmt, ...)
{
	int i, t;
	va_list args;
	char buf[BUFFER_SIZE];

	t = (long long) time;
	va_start(args, fmt);

	vsprintf(buf, fmt, args);

	for (i = 0; buf[i] != '\0'; i++) {
		msleep(t);
		putchar(buf[i]);
	}

	va_end(args);
	return i;
}
